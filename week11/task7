Problem: EasyID;

Types:
Honest = {...};
Dishonest = {...};

Agent = Honest ++ Dishonest;

Functions:
public crypt/2, acrypt/2, pair/2, pk/1, sk/2, kUE/3;
private inv/1, nw/2, nu/2, ne/2, sUE/2;

Facts:
iknows/1, attack/0, secret/3;

Rules:
agents(A: Agent)
=> iknows(A);

publickeys(A: Agent)
=> iknows(pk(A));

privatkeys(D: Dishonest)
=> iknows(inv(pk(D)));

# Symmectric decryption
symdec(K: untyped , M: untyped)
iknows(crypt(K,M)).iknows(K) => iknows(M);

# Symmetric encryption
symenc(K: untyped , M: untyped)
iknows(K).iknows(M) => iknows(crypt(K,M));

# Asymmectric decryption
asymdec(K: untyped , M: untyped)
iknows(acrypt(K,M)).iknows(inv(K)) => iknows(M);

# Asymmetric encryption
asymenc(K: untyped , M: untyped)
iknows(K).iknows(M) => iknows(acrypt(K,M));

# Open signature
opensig(K: untyped, M: untyped)
iknows(acrypt(inv(K),M)) => iknows(M);

pair(M1: untyped , M2: untyped)
iknows(M1).iknows(M2) => iknows(pair(M1,M2));

proj(M1: untyped , M2: untyped)
iknows(pair(M1,M2)) => iknows(M1).iknows(M2);

----------------------------------------------------------------------------------------
W -> U: { W,Nw }inv(pk(W))

U -> e: { U,W,Nu,Nw, sk(U,e) }pk(e)
e -> U: {| U,W,CODE |}kUE(Nu,Nw, sk(U,e))
U -> e: {| U,W,mac(sUE(U), CODE) |}kUE(Nu,Nw, sk(U,e))

e -> W: { { U,W,Nw,KWU }pk(W), {| U,W,KWU |}kUE(Nu,Nw, sk(U,e)) }inv(pk(e))
W -> U: {| U,W,KWU |}kUE(Nu,Nw, sk(U,e))
---------------------------------------------------------------------------------------

# EasyID intruder constraints
easyID1(W: Agent, U: Agent)
=> iknows(acrypt(inv(pk(W)),pair(W,nw(W,U))));

easyID2(U: Agent, W: Agent, E: Honest, NW: untyped)
iknows(acrypt(inv(pk(W)),pair(W,NW)))
=> iknows(acrypt(pk(e),pair(U,pair(W,pair(nu(U,E),pair(NW,sk(U,E)))))));

easyID3(U: Agent, W: Agent, E: Honest, NU: untyped, NW: untyped)
iknows(acrypt(pk(e),pair(U,pair(W,pair(NU,pair(NW,sk(U,E)))))))
=> iknows(crypt(kUE(NU,NW,sk(U,E)),pair(U,pair(W,ne(E,U)))));

easyID4(U: Agent, W: Agent, E: Honest, NU: untyped, NW: untyped, CODE: untyped)
iknows(crypt(kUE(NU,NW,sk(U,E)),pair(U,pair(W,CODE))))
=> iknows(crypt(kUE(NU,NW,sk(U,E)),pair(U,pair(W,CODE)))));

easyID5

easyID6

secrecy1(W: Honest, U: Honest)
iknows(nw(W,U)) => attack;

secrecy2(U: Honest, E: Honest)
iknows(nu(U,E)) => attack;
